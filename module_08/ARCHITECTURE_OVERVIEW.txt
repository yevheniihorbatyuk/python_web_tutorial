================================================================================
                    MODULE 8: COMPLETE ARCHITECTURE OVERVIEW
                   Advanced Databases & Async Processing
================================================================================

HIGH-LEVEL SYSTEM ARCHITECTURE
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│                          CLIENT APPLICATIONS                                │
│                    (Web, Mobile, Desktop Clients)                           │
└────────────────────────────────────┬────────────────────────────────────────┘
                                     │
                    ┌────────────────┴────────────────┐
                    │                                 │
        ┌───────────▼──────────────┐     ┌───────────▼──────────────┐
        │     API LAYER (Sync)     │     │  Background Jobs (Async) │
        │   HTTP/REST Endpoints    │     │    Long-Running Tasks    │
        │   Request Handling       │     │    Event Processing      │
        └───────────┬──────────────┘     └───────────┬──────────────┘
                    │                                 │
        ┌───────────┴──────────────────────────────────┴──────────────┐
        │                    CACHING LAYER                            │
        │              Redis Distributed Cache                        │
        │         (Session Storage, Query Results)                    │
        └───────────┬──────────────────────────────────┬──────────────┘
                    │                                  │
        ┌───────────▼──────────────┐       ┌──────────▼──────────────┐
        │  SYNCHRONOUS             │       │   ASYNCHRONOUS          │
        │  (SQLAlchemy ORM)        │       │   (RabbitMQ Message)    │
        │                          │       │   (Queue Processing)    │
        │  - User Management       │       │                         │
        │  - Product Catalog       │       │  - Email Sending        │
        │  - Transactions          │       │  - Data Enrichment      │
        │  - Business Records      │       │  - Report Generation    │
        │  - Real-time Operations  │       │  - ML Computations      │
        └───────────┬──────────────┘       └──────────┬──────────────┘
                    │                                  │
        ┌───────────▼──────────────────────────────────┴──────────────┐
        │                 MESSAGE BROKER (RabbitMQ)                    │
        │                                                              │
        │  Exchanges:                                                 │
        │  - data_processing (direct)    → User data routing         │
        │  - notifications (topic)       → Pattern-based notification │
        │  - analytics (fanout)          → Broadcast events          │
        │                                                              │
        │  Queues:                                                    │
        │  - user_data_queue             → User processing           │
        │  - notification_queue          → Notifications             │
        │  - analytics_queue             → Analytics                 │
        │  - dlq (dead letter)           → Failed messages           │
        └───────────┬──────────────────────────────────┬──────────────┘
                    │                                  │
        ┌───────────▼──────────────┐       ┌──────────▼──────────────┐
        │     PostgreSQL           │       │  MongoDB (NoSQL)        │
        │    (Relational DB)       │       │  (Document Store)       │
        │                          │       │                         │
        │  Tables:                 │       │  Collections:           │
        │  - Countries             │       │  - events               │
        │  - Cities                │       │  - user_profiles        │
        │  - Addresses             │       │  - analytics            │
        │  - Users                 │       │  - time_series          │
        │  - Products              │       │  - logs                 │
        │  - Orders                │       │                         │
        │                          │       │  Indexes:               │
        │  Features:               │       │  - Geospatial (2dsphere)│
        │  - ACID Transactions     │       │  - Compound indexes     │
        │  - Referential Integrity │       │  - TTL indexes          │
        │  - Complex Joins         │       │                         │
        └───────────┬──────────────┘       └──────────┬──────────────┘
                    │                                  │
                    └────────────────┬─────────────────┘
                                     │
                    ┌────────────────▼────────────────┐
                    │   DATA SCIENCE ENGINE           │
                    │                                 │
                    │  Components:                    │
                    │  - AnalyticsEngine              │
                    │  - MLModelManager               │
                    │  - RecommendationEngine         │
                    │  - InsightsGenerator            │
                    │                                 │
                    │  Outputs:                       │
                    │  - User Segmentation            │
                    │  - Churn Predictions            │
                    │  - LTV Estimates                │
                    │  - Recommendations              │
                    │  - Business Insights            │
                    └────────────────┬────────────────┘
                                     │
                    ┌────────────────▼────────────────┐
                    │     PERSONALIZED RESPONSE       │
                    │      Returned to Client         │
                    └────────────────────────────────┘


MODULE COMPONENT BREAKDOWN
================================================================================

Module 1: SQLAlchemy Advanced ORM (01_sqlalchemy_advanced.py)
──────────────────────────────────────────────────────────────

    User
      └─ Address
          └─ City
              └─ Country

    Classes:
    - User: id, email, username, address_id, profile_score, is_verified
    - Address: id, street, postal_code, city_id
    - City: id, name, region, city_id
    - Country: id, name, code, population, gdp_per_capita

    Repositories:
    - UserRepository: Query users by country/city, get statistics
    - CountryRepository: Country-level analytics
    - DataScienceAnalytics: Cohort analysis, user distribution

    Database: SQLite (or PostgreSQL with migration)
    Connections: Connection pooling, session management
    Queries: Eager loading, aggregations, transactions


Module 2: MongoDB Advanced Patterns (02_mongodb_advanced.py)
──────────────────────────────────────────────────────────────

    Documents:
    - events (time-series data)
      └─ metadata, geo, session_info
    - users (user profiles)
      └─ profile, metrics, subscriptions
    - analytics (aggregated data)

    Managers:
    - MongoDBManager: Schema validation, index creation
    - UserManager: User CRUD, bulk operations
    - EventTracker: Event logging, aggregation pipelines
    - GeoLocationManager: Geospatial queries
    - DataProcessor: Cohort analysis, batch export

    Aggregation Pipelines:
    - Event distribution: $match → $group → $sort
    - User activity: Complex multi-stage pipeline
    - Purchase analytics: Filter, group, aggregate


Module 3: Caching Strategies (03_caching_strategies.py)
────────────────────────────────────────────────────────

    Tier 1: In-Process (@lru_cache)
    ├─ Speed: <0.1ms (fastest!)
    ├─ Scope: Single process
    ├─ Use: Pure functions, deterministic
    └─ Example: fibonacci(n), product_details(id)

    Tier 2: Distributed (Redis)
    ├─ Speed: 1-5ms
    ├─ Scope: Multiple processes/servers
    ├─ Use: Cross-process caching
    └─ Example: user_recommendations, trending_items

    Tier 3: Application Logic (Custom TTL)
    ├─ Speed: Variable (depends on computation)
    ├─ Scope: Complex, domain-specific
    ├─ Use: Custom invalidation logic
    └─ Example: personalized_feed, user_profile

    Classes:
    - FibonacciCalculator: @lru_cache example (11,000x speedup!)
    - RedisCache: Manual cache management
    - RecommendationEngine: Real-world caching pattern
    - MLPredictionService: ML model caching
    - CacheInvalidationManager: Pattern-based invalidation


Module 4: RabbitMQ Messaging (04_rabbitmq_messaging.py)
─────────────────────────────────────────────────────────

    Exchanges:
    - data_processing (direct) 
      └─ User data events with exact routing
    - notifications (topic)
      └─ Email/SMS with pattern-based routing
    - analytics (fanout)
      └─ Events broadcast to all listeners

    Message Types:
    - UserDataMessage: username, email, registration_date
    - NotificationMessage: recipient, subject, content
    - AnalyticsMessage: event_type, user_id, properties

    Producers:
    - publish_user_data_event()
    - publish_notification()
    - publish_analytics_event()

    Consumers:
    - UserDataConsumer: Validate, enrich, store user data
    - NotificationConsumer: Send emails/SMS
    - AnalyticsConsumer: Process events, store data

    Resilience:
    - Retry logic with exponential backoff (2^n seconds)
    - Dead-letter queue for failed messages
    - Priority queues for urgent tasks
    - Message acknowledgment


Module 5: Real-World Data Science (05_realworld_data_science.py)
──────────────────────────────────────────────────────────────────

    User Segments:
    ├─ DORMANT: No activity 90+ days → Re-engagement campaigns
    ├─ ACTIVE: Regular users → Personalized recommendations
    ├─ VIP: High-value users → Premium features/support
    └─ AT_RISK: Churn signals → Retention offers

    Prediction Types:
    ├─ CHURN: Probability user will leave (0-100%)
    ├─ LIFETIME_VALUE: Total revenue expected
    ├─ NEXT_PURCHASE: Days until next purchase
    └─ RECOMMENDATION: Products user might like

    Engines:
    - AnalyticsEngine: User profiling, segmentation, churn/LTV prediction
    - MLModelManager: Prediction dispatch by type
    - RecommendationEngine: Segment-based recommendations
    - InsightsGenerator: Actionable business intelligence

    Algorithms:
    - Churn: Logistic function based on purchase recency
    - LTV: Estimated from purchase frequency and amount
    - Engagement: Weighted score from activities
    - Segment: Based on activity, spending, risk factors


DATA FLOW EXAMPLES
================================================================================

Example 1: User Registration Flow
──────────────────────────────────

1. Client sends: POST /api/users {username, email}

2. API Handler (SQLAlchemy)
   └─ Validates input
   └─ Creates User record in PostgreSQL
   └─ Caches user profile in Redis

3. Event Publishing (RabbitMQ Producer)
   └─ Publishes UserDataMessage to data_processing exchange

4. Background Processing
   ├─ UserDataConsumer receives event
   ├─ Enriches user data (location, preferences)
   ├─ Stores in MongoDB user_profiles
   ├─ Publishes notification
   └─ Queues recommendation calculation

5. Notification Consumer
   └─ Sends welcome email

6. Recommendation Consumer
   ├─ Computes initial recommendations
   ├─ Caches in Redis
   └─ Updates user profile

7. Response to Client
   └─ User created successfully + initial recommendations


Example 2: Real-Time Analytics Pipeline
─────────────────────────────────────────

1. User Event: Click product
   └─ Client sends: POST /api/events {event_type, user_id, data}

2. API Handler (SQLAlchemy + Cache)
   ├─ Updates user engagement in Redis (fast)
   ├─ Counts in PostgreSQL (optional)
   └─ Publishes to analytics exchange

3. Multiple Consumers from Fanout:
   ├─ Consumer 1: Store raw events in MongoDB
   ├─ Consumer 2: Update real-time dashboard
   ├─ Consumer 3: Compute metrics
   └─ Consumer 4: Trigger alerts if needed

4. Analytics Engine
   ├─ Aggregates events using MongoDB pipelines
   ├─ Computes trends
   └─ Generates reports


Example 3: Personalization Flow
────────────────────────────────

1. Client Request: GET /api/users/{id}/recommendations

2. Cache Check (Redis)
   ├─ Hit: Return cached recommendations (1-5ms)
   └─ Miss: Continue to step 3

3. Fetch User Profile (SQLAlchemy)
   └─ Get User + preferences + purchase history

4. AnalyticsEngine.calculate_user_profile()
   ├─ Determine segment (ACTIVE, VIP, etc)
   ├─ Calculate engagement score
   ├─ Predict churn risk
   └─ Estimate lifetime value

5. MLModelManager.predict()
   ├─ Check Redis cache for model results
   └─ Compute if not cached

6. RecommendationEngine.get_recommendations()
   └─ Generate recommendations based on:
      ├─ User segment
      ├─ Purchase history
      ├─ Similar users
      └─ Trending products

7. Cache Results (Redis, 1 hour TTL)
   └─ Store recommendations for next request

8. Return to Client
   └─ Personalized response with recommendations


DEPLOYMENT ARCHITECTURE
================================================================================

                    ┌─────────────────────────────────┐
                    │   Load Balancer / API Gateway   │
                    │    (nginx, AWS ALB)             │
                    └────────────────┬────────────────┘
                                     │
                    ┌────────────────┴────────────────┐
                    │                                 │
            ┌───────▼─────────────┐         ┌────────▼──────────┐
            │   Web Server 1      │         │  Web Server 2     │
            │   (Gunicorn/uWSGI)  │         │  (Gunicorn/uWSGI) │
            └───────┬─────────────┘         └────────┬──────────┘
                    │                                │
            ┌───────┴────────────────────────────────┘
            │
            ▼
    ┌──────────────────────┐
    │   Redis Cluster      │
    │   (Cache Layer)      │
    └──────────────────────┘
            │
    ┌───────┴────────────────┐
    │                        │
┌───▼────────────┐   ┌──────▼──────────┐
│  PostgreSQL    │   │  RabbitMQ       │
│  (Primary DB)  │   │  (Message Bus)  │
└───┬────────────┘   └──────┬──────────┘
    │                       │
    │                 ┌─────┴─────┐
    │                 │           │
    │         ┌───────▼──┐   ┌────▼────────┐
    │         │ Worker 1 │   │  Worker 2   │
    │         │(Celery)  │   │ (Celery)    │
    │         └───────┬──┘   └────┬────────┘
    │                 │           │
    │            ┌────┴───────────┘
    │            │
    │         ┌──▼──────────────┐
    │         │ MongoDB Cluster │
    │         │ (Event Store)   │
    │         └─────────────────┘
    │
    └────────────────────────────────┘


TECHNOLOGY STACK SUMMARY
================================================================================

┌─────────────────────────────────────────────────────────────────────────────┐
│                          TECHNOLOGY CHOICES                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Language:            Python 3.10+                                          │
│  Web Framework:       FastAPI / Flask (not included, use with modules)     │
│                                                                             │
│  PRIMARY DATABASES:                                                         │
│  ├─ PostgreSQL          Relational, ACID, complex queries                  │
│  ├─ MongoDB             NoSQL, flexible schema, time-series data          │
│  └─ Redis              In-memory cache, session storage                    │
│                                                                             │
│  MESSAGE QUEUE:                                                             │
│  └─ RabbitMQ           Reliable async processing, multiple exchanges       │
│                                                                             │
│  DATA SCIENCE:                                                              │
│  ├─ NumPy/Pandas       Data processing and analysis                       │
│  ├─ Scikit-learn       Machine learning models                            │
│  ├─ TensorFlow         Deep learning (optional)                           │
│  └─ Custom Logic       Segmentation, recommendations, insights            │
│                                                                             │
│  CACHING:                                                                   │
│  ├─ functools.lru_cache    In-process caching (built-in)                 │
│  └─ redis-py              Distributed cache client                        │
│                                                                             │
│  ORM/DRIVERS:                                                               │
│  ├─ SQLAlchemy         SQL toolkit and ORM                                │
│  ├─ PyMongo            MongoDB driver                                      │
│  ├─ Motor              Async MongoDB driver                                │
│  └─ pika               RabbitMQ client                                     │
│                                                                             │
│  DEPLOYMENT:                                                                │
│  ├─ Docker/Docker Compose    Containerization                             │
│  ├─ Kubernetes          Container orchestration (advanced)                │
│  ├─ AWS/GCP/Azure       Cloud hosting options                            │
│  └─ Nginx               Load balancing and reverse proxy                   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘


SCALING STRATEGIES
================================================================================

Vertical Scaling (Single Server)
────────────────────────────────
└─ Increase CPU, RAM, storage
└─ Good for: MVP, startup phase
└─ Limitations: Single point of failure


Horizontal Scaling (Multiple Servers)
──────────────────────────────────────
├─ PostgreSQL
│  └─ Primary + Replicas (read scaling)
│  └─ Sharding by user_id (write scaling)
│
├─ MongoDB
│  └─ Replica sets (high availability)
│  └─ Sharding (horizontal scaling)
│
├─ Redis
│  └─ Redis Cluster (distributed cache)
│  └─ Sentinel (high availability)
│
├─ RabbitMQ
│  └─ RabbitMQ Cluster (multiple brokers)
│
└─ Web Servers
   └─ Load balancer + multiple instances


Microservices Architecture
───────────────────────────
├─ API Gateway
├─ User Service
├─ Product Service
├─ Recommendation Service
├─ Notification Service
├─ Analytics Service
└─ Shared Services (DB, Cache, Message Queue)


MONITORING & OBSERVABILITY
================================================================================

Database Metrics:
  ├─ Query execution time (p50, p95, p99)
  ├─ Connection pool usage
  ├─ Slow query log
  ├─ Index hit ratio

Cache Metrics:
  ├─ Hit ratio (should be >70%)
  ├─ Eviction rate
  ├─ Memory usage
  ├─ Key distribution

Message Queue Metrics:
  ├─ Queue depth
  ├─ Message latency
  ├─ Error rate
  ├─ Consumer lag
  ├─ Dead letter queue size

Application Metrics:
  ├─ Request latency
  ├─ Error rate
  ├─ Throughput (requests/sec)
  ├─ Active users
  ├─ Conversion rates

Alerts to Set:
  ├─ Database connection pool > 80%
  ├─ Redis memory > 80%
  ├─ RabbitMQ queue depth > 10,000
  ├─ Query time > 100ms
  ├─ Cache hit ratio < 70%
  ├─ Message error rate > 1%

================================================================================
                              END OF OVERVIEW
================================================================================
